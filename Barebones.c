#pragma config(Sensor, dgtl1,  PRT_gunLeftQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  PRT_gunRightQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, PRT_ledR,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, PRT_ledY,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, PRT_ledG,       sensorLEDtoVCC)
#pragma config(Motor,  port1,           feedLower,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           wheelFrontLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           wheelFrontRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           wheelBackLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           wheelBackRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           gunLeft1,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           gunLeft2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           gunRight1,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           gunRight2,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          feedUpper,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////
//                                --= BAREBONES =--                                 //
//////////////////////////////////////////////////////////////////////////////////////
// Barebones is a minimalist programming backup that provides bare minimum          //
// functionality to the robot. In the case of a code emergency, barebones can be    //
// downloaded to ensure the user has secure control of the robot, but will not have //
// intelligent, closed-loop logic that improves driving quality.                    //
//////////////////////////////////////////////////////////////////////////////////////

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void pre_auton()
{
	bStopTasksBetweenModes = false;
}

task autonomous()
{
	AutonomousCodePlaceholderForTesting();
}

int delta = 0;
int power = 0;
bool gunButtonDown = false;
bool gunButtonDownPrevious = false;
bool warmGuns = false;
task guncontrol()
{
	while (true) {
		while (warmGuns) {
			if (power < 100 && delta <= time1[T1]) {
				power += 10;
				delta = time1[T1] + 1000;
			}
			motor[gunLeft1] = power;
			motor[gunLeft2] = power;
			motor[gunRight1] = power;
			motor[gunRight2] = power;
		}
		power = 0;
		delta = 0;
		motor[gunLeft1] = power;
		motor[gunLeft2] = power;
		motor[gunRight1] = power;
		motor[gunRight2] = power;
	}
}

task usercontrol()
{
	clearTimer(T1);
	startTask(guncontrol);
	while (true) {
		// Gun Control
		gunButtonDownPrevious = gunButtonDown;
		if (vexRT[Btn8D] == true) {
			gunButtonDown = true;
		}
		if (gunButtonDownPrevious == true && gunButtonDown == false) {
			warmGuns = !warmGuns;
			gunButtonDown = false;
		}

		// Feed Control
		if (vexRT[Btn5U] == true) {
			motor[feedLower] = 127;
		} else if (vexRT[Btn5D] == true) {
			motor[feedLower] = -127;
		} else {
			motor[feedLower] = 0;
		}

		if (vexRT[Btn6U] == true) {
			motor[feedUpper] = 127;
		} else if (vexRT[Btn6D] == true) {
			motor[feedUpper] = -127;
		} else {
			motor[feedUpper] = 0;
		}

		// Wheel Control
		motor[wheelFrontLeft] = vexRT[Ch3];
		motor[wheelBackLeft] = vexRT[Ch3];
		motor[wheelFrontRight] = vexRT[Ch2];
		motor[wheelBackRight] = vexRT[Ch2];
	}
}
